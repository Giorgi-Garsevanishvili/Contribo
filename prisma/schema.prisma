datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id             String          @id @default(cuid())
  name           String?
  email          String          @unique
  emailVerified  DateTime?
  image          String?
  regionId       String?
  region         Region?         @relation(fields: [regionId], references: [id], onDelete: SetNull)
  roles          UserRole[]      @relation("roleForUsers")
  memberStatusId String?
  memberStatus   MemberStatus?   @relation(fields: [memberStatusId], references: [id], onDelete: SetNull)
  reqStatus      ReqStatus       @default(PENDING)
  positionId     String?
  position       Position?       @relation(fields: [positionId], references: [id], onDelete: SetNull)
  rating         Int             @default(0)
  deletedAt      DateTime?
  deleted        Boolean         @default(false)
  accounts       Account[]
  sessions       Session[]
  // Optional for WebAuthn support
  Authenticator  Authenticator[]
  joinRequests   JoinRequest[]

  createdAt           DateTime          @default(now())
  updatedAt           DateTime?         @updatedAt
  memberStatusLogs    MemberStatusLog[]
  memberStatusChanges MemberStatusLog[] @relation("MembershipChangedBy")
  positionChanges     PositionHistory[] @relation("PositionChangedBy")
  positionHistories   PositionHistory[]
  ratingHistory       RatingHistory[]   @relation("UserRating")
  createdRating       RatingHistory[]   @relation("CreatedRatingBy")

  eventAssignments     EventAssignment[]
  providedFeedbacks    EventFeedback[]
  scheduledEventEmails ScheduledEmails[]
  hrWarnings           HrWarning[]       @relation("HrWarnings")
  createdHrWarning     HrWarning[]       @relation("CreatedHrWarnings")
  CreatedAllowedUser   AllowedUser[] @relation("createdAllowanceBy")
  ownAllowance AllowedUser[] @relation("ownAllowance")
}

//Roles and Region data must be moved to allowed user table and make reference between user and allowed user so allowed user table will be main access and region controller for user, and during the fetch user we can include allowed user table and modify data based on that

enum RatingAction {
  INCREASE
  DECREASE
}

model Event {
  id          String   @id @default(cuid())
  name        String
  location    String
  startTime   DateTime
  endTime     DateTime
  description String
  rating      Int?

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  feedback             EventFeedback[]
  assignments          EventAssignment[]
  scheduledEventEmails ScheduledEmails[]
}

model EventsRole {
  id        String    @id @default(cuid())
  name      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
  type      GTypes    @default(REGION)

  eventAssignment EventAssignment[]
}

enum GTypes {
  SYSTEM
  REGION
}

model HrWarning {
  id          String          @id @default(cuid())
  name        String
  typeId      String
  type        HrWarningType   @relation(fields: [typeId], references: [id], onDelete: Cascade)
  assigneeID  String
  assignee    User            @relation("HrWarnings", fields: [assigneeID], references: [id], onDelete: Cascade)
  comment     String?
  status      HrWarningStatus @default(ACTIVE)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime?       @updatedAt
  createdById String?
  createdBy   User?           @relation("CreatedHrWarnings", fields: [createdById], references: [id], onDelete: SetNull)
}

model HrWarningType {
  id        String    @id @default(cuid())
  name      String    @unique
  type      GTypes    @default(REGION)
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  hrWarning HrWarning[]
}

enum HrWarningStatus {
  ACTIVE // The warning is currently valid
  UNDER_REVIEW // Being reviewed by HR or management
  APPROVED // Approved by supervisor or HR
  ESCALATED // Escalated to higher authority
  RESOLVED // Issue resolved, but kept for record
  CANCELLED // Warning cancelled before approval
  EXPIRED // Automatically expired after a date
  ARCHIVED // Old but retained for historical record
}

model EventFeedback {
  id       String  @id @default(cuid())
  eventId  String
  userId   String?
  feedback String
  rating   Int?

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User? @relation(fields: [userId], references: [id], onDelete: SetNull)
}

model ScheduledEmails {
  id        String    @id @default(cuid())
  userId    String
  eventId   String
  sent      Boolean   @default(false)
  sendAt    DateTime
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model EventAssignment {
  id      String  @id @default(cuid())
  eventId String
  userId  String?
  roleId  String?

  comment    String?
  assignedAt DateTime  @default(now())
  validFrom  DateTime?
  validTo    DateTime?

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  role  EventsRole? @relation(fields: [roleId], references: [id], onDelete: SetNull)
  event Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
}

model RatingHistory {
  id          String       @id @default(cuid())
  userId      String
  value       Int
  action      RatingAction
  reason      String?
  createdById String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime?    @updatedAt

  user      User  @relation("UserRating", fields: [userId], references: [id], onDelete: Cascade)
  createdBy User? @relation("CreatedRatingBy", fields: [createdById], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([createdById])
}

model Position {
  id                String            @id @default(cuid())
  name              String            @unique
  type              GTypes            @default(REGION)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime?         @updatedAt
  users             User[]
  positionHistories PositionHistory[]
}

model PositionHistory {
  id          String    @id @default(cuid())
  userId      String
  positionId  String?
  startedAt   DateTime  @default(now())
  endedAt     DateTime?
  changedAt   DateTime  @default(now())
  updatedById String?
  changedBy   User?     @relation("PositionChangedBy", fields: [updatedById], references: [id], onDelete: SetNull)

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  position Position? @relation(fields: [positionId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([updatedById])
}

model MemberStatus {
  id               String            @id @default(cuid())
  name             String            @unique
  type             GTypes            @default(REGION)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime?         @updatedAt
  users            User[]
  memberStatusLogs MemberStatusLog[]
}

model MemberStatusLog {
  id             String    @id @default(cuid())
  userId         String
  memberStatusId String?
  startedAt      DateTime  @default(now())
  endedAt        DateTime?
  changedAt      DateTime  @default(now())
  changedById    String?
  changedBy      User?     @relation("MembershipChangedBy", fields: [changedById], references: [id], onDelete: SetNull)

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  status MemberStatus? @relation(fields: [memberStatusId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([changedById])
}

model JoinRequest {
  id          String    @id @default(cuid())
  userId      String
  regionId    String?
  status      ReqStatus @default(PENDING)
  requestedAt DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  region Region? @relation(fields: [regionId], references: [id], onDelete: SetNull)
}

enum ReqStatus {
  PENDING
  REQUESTED
  APPROVED
  REJECTED
}

model Region {
  id          String       @id @default(cuid())
  name        String       @unique
  logo        String?
  email       String?      @unique
  phone       String?
  description String?
  address     String?
  website     String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  status      RegionStatus @default(PENDING)

  users        User[]
  allowedUsers AllowedUser[]
  joinRequests JoinRequest[]
}

enum RegionStatus {
  ACTIVE
  PAUSED
  DEACTIVATED
  PENDING
}

model UserRole {
  userId String
  roleId String

  user User @relation("roleForUsers", fields: [userId], references: [id])
  role Role @relation("userForRoles", fields: [roleId], references: [id])

  @@id([userId, roleId])
}

model AllowedUser {
  id        String  @id @default(cuid())
  email     String  @unique
  roleId    String?
  regionId  String?
  creatorId String?
  region    Region? @relation(fields: [regionId], references: [id], onDelete: SetNull)
  role      Role?   @relation(fields: [roleId], references: [id], onDelete: SetNull)
  type      GTypes  @default(REGION)

  createdBy User? @relation("createdAllowanceBy",fields: [creatorId], references: [id], onDelete: SetNull)

  user User? @relation("ownAllowance",fields: [email], references: [email])
  updatedAt DateTime? @updatedAt
  createdAt DateTime  @default(now())
}

model Role {
  id          String        @id @default(uuid())
  name        String        @unique
  createdAt   DateTime      @default(now())
  updatedAt   DateTime?     @updatedAt
  allowedUser AllowedUser[]
  userRoles   UserRole[]    @relation("userForRoles")
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}
